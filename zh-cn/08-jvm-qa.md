# JVM QA

![访问统计](https://visitor-badge.glitch.me/badge?page_id=senlypan.jvm.08-jvm-qa&left_color=blue&right_color=red)

## 1、简单说一下JVM的内存模型？jvm内存区域划分是怎样的？

- 预读
    - [走进 JVM](/zh-cn/02-jvm)
    - [JVM 整体架构](/zh-cn/02-jvm-framework)
    - [JVM 运行时内存](/zh-cn/02-jvm-runtime-memory) （本篇涉及多个问题域，可深读）
    - 1、首先，整个 JVM 分为 [五大模块](/zh-cn/02-jvm-framework)： 
        - [类装载器子系统](/zh-cn/06-class-loading-subsystem) 
        - 运行时数据区 
        - 执行引擎 
        - 本地方法接口
        - 垃圾收集
    - 2、根据 JVM 规范，[JVM 内存结构（运行时数据区）](/zh-cn/02-jvm-runtime-memory) 共分为五个部分：
        - （线程私有）虚拟机栈
        - （线程私有）本地方法栈
        - （线程私有）程序计数器
        - （共享）堆
        - （共享）方法区
- 回答
    - chatGPT:
        - 简单说一下JVM的内存模型？
            - Java虚拟机（JVM）的内存模型是一种用于管理Java应用程序的内存的抽象模型。JVM的内存模型由多个内存区域组成，如堆，方法区，程序计数器等。
            - 堆是JVM中最大的内存区域，所有的Java对象实例和数组都将分配在堆内存中。堆内存是由Java垃圾回收器（GC）管理的，它负责监控对象的生命周期并回收不再使用的对象。
            - 方法区是存储类信息，常量，静态变量和即时编译器编译后的代码的内存区域。
            - 程序计数器是一个小的内存区域，用于跟踪正在执行的Java字节码的位置。
            - 此外，JVM还具有本地方法栈和栈帧，它们主要用于维护Java方法的执行状态。
            - 总之，JVM内存模型为Java应用程序提供了一种管理内存的机制，以确保程序的正常运行。
        - jvm内存区域划分是怎样的？
            - JVM内存区域通常分为以下几个部分：
                - 堆：是Java应用程序的主要内存区域，所有的Java对象实例和数组都将分配在堆内存中。它是由Java垃圾回收器（GC）管理的，确保内存中不再使用的对象被回收。
                - 方法区：存储类信息，常量，静态变量和即时编译器编译后的代码。它也是由GC管理的，但因为它存储的是类信息，因此不会产生内存泄漏。
                - 程序计数器：是一个小的内存区域，用于跟踪当前执行的Java字节码的位置。
                - 本地方法栈：主要用于维护Java方法的执行状态，其中包含了Java方法的调用和返回地址。
                - 栈帧：是本地方法栈的一个子部分，主要用于存储方法调用时的局部变量，操作数栈，动态链接和方法返回值。
                - 总的来说，JVM内存划分是一个复杂的系统，但它以抽象的方式管理Java应用程序的内存，以确保程序的正常运行。

## 2、常见的垃圾回收器，和他们的区别说说？

- 预读
    - [走近 GC](/zh-cn/03-gc)（含介绍 10 种常见收集器）
    - [美团 | Java中9种常见的CMS GC问题分析与解决](https://tech.meituan.com/2020/11/12/java-9-cms-gc.html)
    - [经典垃圾收集器](/zh-cn/03-classic-gc)（含多种常见收集器对比）
    - **GC 垃圾回收 - 360 网盘 PDF 电子版**
    - 以往项目 JVM 参数配置与 GC 指定情况：
    ```shell

        MICRO_PROFILES_ACTIVE=dev,devall
        MICRO_SERVER_NAME=micro-jyjia-manage-community-online;
        MICRO_NAME=flower;
        nohup java -jar -server 

        -Xmx256m -Xms256m -Xmn128m -Xss256K 
        -XX:LargePageSizeInBytes=128M -XX:+DisableExplicitGC -XX:SurvivorRatio=1 
        -XX:+UseConcMarkSweepGC -XX:+UseParNewGC 
        -XX:+CMSParallelRemarkEnabled -XX:+UseCMSCompactAtFullCollection 
        -XX:CMSFullGCsBeforeCompaction=0 -XX:+CMSClassUnloadingEnabled 
        -XX:+UseFastAccessorMethods -XX:+UseCMSInitiatingOccupancyOnly 
        -XX:CMSInitiatingOccupancyFraction=80 -XX:SoftRefLRUPolicyMSPerMB=0 
        -XX:+PrintClassHistogram -XX:+PrintGCDetails -XX:+PrintGCTimeStamps 
        -XX:+PrintHeapAtGC -XX:+HeapDumpOnOutOfMemoryError 
        -XX:HeapDumpPath=/var/log/java/heap.$MICRO_SERVER_NAME.bin 

        -javaagent:/mnt/local/agent/skywalking-agent.jar 
        -Dskywalking.agent.service_name=$MICRO_SERVER_NAME 
        -Dskywalking.trace.ignore_path=/$MICRO_NAME/actuator/**,/instances 
        -Dapollo.meta.ip=http://10.66.99.180:8080/,http://10.31.15.48:8080 
        
        ./$MICRO_SERVER_NAME.jar 2> /dev/null &
    ```
- 回答
    - chatGPT:
        - 常见的垃圾回收器，和他们的区别说说？
            - JVM内置了多种垃圾回收器，常见的垃圾回收器包括：
                - 1、Serial GC: 这是最简单的垃圾回收器，单线程进行垃圾回收。它适用于单核处理器环境，速度较快，但可能不够适用于多核处理器环境。
                - 2、Parallel GC (also known as Throughput GC): 这是Serial GC的多线程版本，适用于多核处理器环境。它使用多个线程并行执行垃圾回收，以提高性能。
                - 3、CMS (Concurrent Mark Sweep) GC: 这是一种并发的垃圾回收器，可以在不停止应用程序的情况下执行垃圾回收。它适用于服务器环境，因为它可以保证服务器的连续运行。
                - 4、G1 GC (Garbage-First GC): 这是一种全新的垃圾回收器，具有并行，并发，分代的特点。它与CMS GC类似，但更加先进，能够更好地适应大型Java应用程序的内存需求。
                - 以上是JVM内置的常见垃圾回收器，每种垃圾回收器都有各自的优点和缺点。选择哪种垃圾回收器需要根据应用程序的需求和硬件环境来进行决策。

## 3、为什么要划分成年轻代和老年代？说说G1垃圾回收器？老年代，年轻代如何分配？

- 堆区为什么要分为新生代和老年代？
    - JVM将堆内存分为新生代和老年代是 **为了提高垃圾回收的效率**。
    - 大部分Java对象都很短命，在创建后不久就被回收，因此将新创建的对象存储在新生代内存区域中，可以快速回收这些对象。同时，新生代的内存容量较小，因此垃圾回收的代价也比较低。
    - 而长期存活的对象将被移动到老年代内存区域中，因为老年代的内存容量比较大，所以采用不同的垃圾回收算法，以提高效率。
    - 通过将堆内存分为新生代和老年代，**JVM可以快速回收短命的对象，并高效管理长期存活的对象，从而提高内存利用率，减少内存碎片**。

- 说说G1垃圾回收器？
    - G1 (Garbage First)是Java HotSpot虚拟机（JVM）中的一种垃圾回收器，**它是一种分代收集器，同时它也是一种多区域收集器**。
    - G1回收器的目标是通过平衡内存使用和垃圾回收时间来提高系统的吞吐量。它将内存堆分为若干个不同的区域（region），并对不同的区域使用不同的回收策略，以提高回收效率。
    - G1通过不断监测堆中的内存使用情况，并利用“懒惰分配”策略来减少停顿时间。在回收时，G1只回收那些空间利用率较低的区域，这样可以最大限度地减少停顿时间。
    - 总的来说，G1垃圾回收器是一种 **高效，低停顿** 的垃圾回收器，特别适合大型的内存分配应用程序。

- G1老年代，年轻代如何分配？
    - G1垃圾回收器将Java堆分为多个不同的区域，这些区域可以被分为两个主要的部分：年轻代和老年代。
    - 年轻代包括Eden区和两个Survivor区。Eden区是用于存储新创建的对象的区域，Survivor区则是用于存储在Eden区中存活下来的对象的区域。在年轻代中，G1回收器会使用复制算法，将存活的对象从一个Survivor区移动到另一个Survivor区。
    - 老年代是用于存储在年轻代中经过多次回收后仍然存活的对象的区域。G1回收器通过不断监测堆中的内存使用情况，以确定哪些区域应该被认为是老年代。
    - 总的来说，G1垃圾回收器通过不断监测内存使用情况，以决定哪些区域应该归入年轻代，哪些应该归入老年代。这种灵活的方法可以有效地利用内存，同时也有助于减少停顿时间。
    - **GC 垃圾回收 - 360 网盘 PDF 电子版 / 4.8 G1收集器**

## 4、年轻代为什么被划分成 eden、survivor 区域？

- 年轻代为什么被划分成 eden、survivor 区域？ 
    - 年轻代之所以被划分为Eden和Survivor区域，是为了实现内存回收的效率和管理对象生命周期的需要。
    - Eden区是存储新创建的对象的区域，也是最常用的内存区域。因为大多数对象在创建后很快就被回收，因此Eden区的内存利用率比较高。
    - Survivor区是存储在Eden区中存活下来的对象的区域。当Eden区内存使用量达到一定程度时，垃圾回收器就会执行回收。在回收过程中，所有存活的对象会被复制到Survivor区，而不再使用的对象会被回收。
    - 两个Survivor区可以互相轮流使用，以确保复制过程的连续性。当一个Survivor区内存使用量达到一定程度时，存活的对象会被移动到另一个Survivor区。
    - 因此，将年轻代划分为Eden和Survivor区域，可以更好地管理对象的生命周期，提高内存回收的效率，从而提高系统性能。

- 为什么要有 Survivor 区 ？
    - 如果没有 Survivor 区，那么 Eden 每次满了清理垃圾，存活的对象被迁移到老年区，老年区满了，就会触发非常耗时的Full GC，解决办法：
        - 1、增加老年代内存，那么老年代清理频次减少，但清理一次花费时间更长。
        - 2、减少老年代内存，老年代一次 Full GC 时间更少，频率增加。
    - 都不行，只有再加一层 Survivor。将 Eden 区满了的对象，添加到 Survivor 区，等对象反复清理几遍之后都没清理掉，再放到老年区，这样老年区的压力就会小很多。即 Survivor 相当于一个筛子，筛掉生命周期短的，将生命周期长的放到老年代区，减少老年代被清理的次数。

- 为什么要加两个 Survivor ？
    - 避免产生内存碎片。为了不产生内存碎片，才用复制算法，将 Eden 区和 Survivor 区存活的对象整齐的放到一个空的内存。因为生命周期一般都比较短，所以在存活对象不多的情况下，复制算法效率还是比较高的。
    - 并且设计多一个空内存区，即有三个区，就总可以保持一个是空的，这样清理垃圾的时候，就可以将存活对象全部都整齐的放到一个空的内存中，不产生内存碎片了。

## 5、年轻代为什么采用的是复制算法？

JVM的年轻代采用复制算法的原因有以下几点：

- 效率高：复制算法不需要维护内存间的引用关系，直接把存活的对象复制到另一个内存区域中，因此它的执行速度很快。

- 分配连续的内存空间：在复制算法中，年轻代的内存分配连续，可以方便地管理堆内存。

- 保证垃圾回收的正确性：复制算法简单易行，易于实现，可以保证垃圾回收的正确性。

因此，JVM采用复制算法来管理年轻代内存是一个明智的决策。

## 6、老年代为什么采用的是标记清除、标记整理算法？

Java虚拟机(JVM)采用标记清除和标记整理算法是因为它们具有一定的优点：

- 标记清除：简单且实现灵活。它在垃圾收集时只回收未标记对象，并不需要进行内存整理。

- 标记整理：更高效，因为它避免了内存碎片的产生。它标记所有存活的对象，并移动它们到内存的一端，以避免空间碎片的产生。

JVM的堆内存被设计为用于存储大量的对象实例，并且在垃圾收集时需要扫描大量的对象。因此，标记整理算法在这种情况下可能更适合，但它需要更多的计算资源，以消除内存碎片。因此，JVM通常使用标记清除和标记整理的混合算法，以在垃圾收集时获得最佳的性能。

## 7、什么情况下使用堆外内存？要注意些什么？

Java虚拟机(JVM)在以下情况下使用堆外内存：

1、对象数据较大：当对象数据较大，并且不需要频繁访问，JVM可以选择将这些数据存储在堆外内存中，以节约堆内存的空间。

2、数组大小超过阈值：JVM在配置中有一个数组大小阈值，当数组大小超过此阈值时，JVM可以将数组存储在堆外内存中。

3、高速缓存：堆外内存可用于存储缓存数据，例如图像、视频等多媒体文件，以便在需要时快速访问。

4、本机内存不足：当系统的物理内存不足以支持JVM的工作时，JVM可以使用堆外内存。**但是，在这种情况下，需要小心内存泄漏和其他问题，因为堆外内存不受JVM的垃圾回收机制管理。**

需要注意的是，使用堆外内存需要更多的编码工作（Unsafe/ByteBUffer-netty），并且需要更多的编码经验，以确保程序的正确性和可靠性。因此，在使用堆外内存前，应该仔细评估是否有必要使用，以及是否有更简单的解决方案。

- [java堆外内存详解（又名直接内存）和 ByteBuffer](https://it.cha138.com/nginx/show-314049.html)


## 8、堆外内存如何被回收？

JVM 堆外内存不在 JVM 管辖范围内，因此不会被 JVM 自动回收。需要显式地调用相关 API 进行回收。

在 Java 中，堆外内存通常是通过直接内存（Direct Memory）实现的，它是通过 `sun.misc.Unsafe` 类来操作的。如果直接内存用完了，程序会抛出 OutOfMemoryError 异常。因此，在使用堆外内存时需要特别小心，以避免内存泄露和内存溢出。

为了解决堆外内存的回收问题，可以使用相关的管理工具，例如 

- **Java Native Interface (JNI)**
- **Java Native Access (JNA)** 等。

这些工具允许你在 Java 应用程序中调用本地代码，并通过本地代码管理堆外内存的生命周期。

## 9、对 java 多态、封装、继承的理解？

Java 多态、封装、继承是面向对象编程（OOP）的三大特性。

- 多态：多态性是指一个对象可以在不同情况下具有不同的形态。它是通过同一方法名称调用不同的方法实现的，比如说有一个方法makeSound，不同的对象实现了不同的makeSound，在调用这个方法时，会根据对象的类型来调用不同的实现。

- 封装：封装是指将对象的实现细节隐藏在对象内部，只向外界提供公共的访问接口。封装的好处是隔离了实现细节，可以有效地防止对象状态的混乱和对象的实现细节的改变对外部的影响。

- 继承：继承是指在已有的类的基础上定义新的类，新的类称为子类，已有的类称为父类。子类继承父类的属性和方法，可以重写父类的方法，也可以定义新的方法。继承的好处是可以大大减少代码的重复，提高代码的复用性。

通过这三个特性的结合，可以实现面向对象编程的思想，有效地封装了程序的细节，使程序更易于维护和扩展。

## 10、什么情况下栈会溢出？

Java虚拟机栈（JVM Stack）是线程私有的，它存储了方法的局部变量、方法调用信息以及返回值。JVM栈可以理解为是线程内存，它在线程创建时创建，在线程结束时销毁。

JVM栈的溢出发生在以下情况：

- 递归调用：如果一个方法调用自身，并且调用次数太多，会导致栈溢出。

- 方法调用深度过深：当方法调用嵌套层数过深，栈的空间可能不够用，导致栈溢出。

- 数组大小过大：当定义数组时，如果数组大小过大，可能会导致栈溢出。（java默认栈大小是1M，例如 1024*1024 二维数组，大概在 4 M 左右）

在遇到栈溢出的情况时，JVM会抛出StackOverflowError异常。为了避免栈溢出，我们需要避免递归调用的过多，减少方法调用的深度，并且要尽量避免定义过大的数组。

## 11、说一下类加载过程，双亲委派模型源码看过吗？介绍一下？为什么要设计双亲委派模型？

- java 类加载过程？
    - Java类的加载过程涉及到Java虚拟机的类加载子系统。类加载子系统是Java虚拟机的一个重要组成部分，负责从Java字节码文件中加载类，并将其转换为Java虚拟机可以执行的形式。下面是Java类加载过程的大致步骤：
        - 1、类加载请求：当程序需要使用某个类时，类加载子系统会收到一个类加载请求。
        - 2、检查缓存：类加载子系统首先检查该类是否已经被加载过，如果是，则直接使用缓存中的类对象，不再重复加载。
        - 3、加载二进制字节码：如果该类没有被加载过，类加载器会从硬盘或网络中加载该类的二进制字节码文件。
        - 4、验证字节码：加载的字节码文件必须经过验证，以确保该类的正确性和安全性。
        - 5、转换字节码：经过验证的字节码文件需要被转换成Java虚拟机可以执行的形式。
        - 6、创建类对象：最后，类加载子系统会创建一个类对象，并将其缓存在内存。

- 什么是java双亲委派模型？
    - Java双亲委派模型是Java类加载机制的一种设计模式。它的核心思想是：在加载一个类时，优先由上层的类加载器加载，如果上层类加载器无法加载该类，则由下层类加载器加载，直到最后一层类加载器都无法加载该类为止。这种设计模式有几个优点：
        - 1、保证Java核心类库的安全性：由根类加载器加载的核心类库，是不能被用户自定义的类加载器加载的，从而保证了Java核心类库的安全性。
        - 2、保证一个类只被加载一次：如果多个类加载器都试图加载一个类，那么双亲委派模型保证了该类只被加载一次，避免了类的重复加载。
        - 3、提高类加载的效率：由父类加载器先加载，如果父类加载器加载不了，再由子类加载器加载，这样可以大大提高类加载的效率。
    - 因此，Java双亲委派模型是一种很好的类加载机制，能够保证Java类库的安全性和一致性，并且提高了类加载的效率。

- 根类加载器为什么不能加载自定义类？
    - 根类加载器（Bootstrap ClassLoader）是 Java 虚拟机最顶层的类加载器，负责加载jdk中的核心类库。由 C++ 实现，不是 classLoader 的子类，例如 java.lang 包中的类。因为根类加载器是用本地代码实现的，所以它不能加载自定义类。
    - 而自定义类通常由用户定义的类加载器（例如，应用程序类加载器）加载，这些类加载器通常是由 Java 代码实现的，并从类路径中加载类。因此，根类加载器不能加载自定义类，但其他类加载器可以。
    - 总的来说，Java 类加载器体系是用于管理类加载过程的，并确保 Java 虚拟机可以安全地加载类。每个类加载器都有其职责和限制，根类加载器的限制就是不能加载自定义类。


- 参考：
  * [类加载子系统](/zh-cn/06-class-loading-subsystem.md)
  * [类加载器](/zh-cn/06-class-loader.md)
  * [类文件结构](/zh-cn/00-404.md)
  * [类加载机制](/zh-cn/00-404.md)
  * [双亲委派模型](/zh-cn/06-parents-delegation-model.md)
  * [自定义类加载器](/zh-cn/06-define-class-loader.md)
  * [ClassLoader源码分析](/zh-cn/06-class-loader-source-analy.md)

## 12、Java 常用指令与可视化调优有哪些？

- [常用指令与可视化调优](/zh-cn/05-gc-command-and-visual-tuning)

## 13、有做过哪些GC调优？

压测 - 分析

- 程序压测工具
    - JMeter
- GC 分析工具
    - GCeasy
        - https://gceasy.io/
    - GCviewer

- 我的基本思路
    - 切换垃圾回收器
    - 调整堆大小
    - 调整新老代的比例
    - 调整幸存者区比例    
    - 调整最大停顿时间

## 14、遇到 OOM 常见的排查方式和解决方案？

- [常见内存溢出异常](/zh-cn/02-jvm-out-of-memory-error)

## 15、字节码增强有哪些方式？

## 16、JVM 调优手段有哪些？举个生产上的例子

## 17、JVM 堆说一下？触发 Full GC 的场景有哪些？

- JVM 堆说一下？
    - 堆是JVM中最大的内存区域，所有的Java对象实例和数组都将分配在堆内存中。堆内存是由Java垃圾回收器（GC）管理的，它负责监控对象的生命周期并回收不再使用的对象。

## 18、java 为什么入口是 main 方法？有什么用？