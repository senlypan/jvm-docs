# 走近GC

> 作者: 潘深练
>
> 更新: 2022-02-28

## ✨ 内容已经在梳理，持续发布
?> ❤️ 您也可以参与梳理，快来提交 [issue](https://github.com/senlypan/jvm-docs/issues) 或投稿参与吧~

垃圾回收算法解决两个问题：`识别垃圾`和`清除垃圾`。

- **识别垃圾** 的思路有两种：`引用计数`和`遍历标记`。
- **清除垃圾**的方式也有两种：`原地回收`和`复制回收`。

各路算法按照这两种思路和方式的结合，通过各种方式去缩短GC暂停时间、提供堆使用率、保持程序局部性等。

- 参考 JDK 10 [JEP 304: Garbage Collector Interface](https://openjdk.java.net/jeps/304)
- 参考 JDK 11 [JEP 333: ZGC: A Scalable Low-Latency Garbage Collector](https://openjdk.java.net/jeps/333)

## 原地回收

> 原地回收的算法主要有引用计数算法和标记清除算法。

**引用计数算法** 是引用计数和原地回收的结合。它具有GC最大暂停时间短、可以保持程序局部性的优点，但是存在循环引用对象不能清除、引用计数位频繁更新的缺点。部分标记清除算法对root引用对象转移做了特殊处理，使用标记清除算法来识别垃圾，避免了循环引用对象不被root引用后，不能被清除的问题。Sticky 引用计数法和ZCT引用计数法分别通过忽略计数位溢出，延迟计数位更新的方法减缓了引用计数位频繁更新的问题。

**标记清除算法** 是标记和原地回收的结合。作为一种保守式GC算法，它不需要移动对象，不需要更新引用指针，经常是其他GC算法（如部分标记清除算法，Ungar分代GC算法）的补充手段。标记清除算法存在内存碎片化、不兼容写时复制技术的缺点。通过规整分块大小（BiBOP）可以减缓内存碎片。使用位图记录标记位可以使其兼容写时复制技术。

## 复制回收

> 通过复制活动对象来进行垃圾回收的算法大部分使用了标记来识别垃圾。

**标记整理算法** 是标记和复制算法的结合。它通过将活动对象挪到一起来回收空闲空间，解决了标记清除算法带来的堆内存碎片问题。LISP2算法在移动对象过程中会保持对象顺序，可以保持程序的局部性，但是需要三次遍历堆（分别是计算对象新位置、更新指针、移动对象），导致GC暂停时间过长。Two-Finger算法在对象大小一致的前提下，采用类似于交换排序的方式，将空闲的内存块移动到堆末尾，它将遍历堆的次数从3次降低到2次。表格算法通过对象群和间隙表格，在保持2次遍历的基础上，维持了堆内对象的顺序，而且不要求对象大小一致。

**分代GC** 侧重解决复制带来的GC最大暂停时间过长问题。利用大部分对象生成后会很快被销毁的特点，将堆分成多个区间（代），在不同代之间采用不同的垃圾识别算法，并且保持不同的GC频率。通过减少每次GC扫描的对象来缩短GC暂停时间。Ungar算法将堆分成新生代和老生代，新生代使用复制算法，在老生代采用标记清除算法。同时它通过记录集和写屏障，保证被老生代对象引用的新生代对象不会被回收。列车算法在老生代也采用复制回收算法，它可以减少老生代GC的最大暂停时间，但代价是写屏障会更加繁重。

**渐进式GC** 则是针对标记清除算法的一种改进，它把GC的过程分成扫描root、遍历扫描堆、清除堆内垃圾三个阶段，每个阶段都可以暂停下来，以此到达减少GC最大暂停时间的效果。为了记住对象是否被扫描过，需要使用三色标记法对对象进行标记，并且使用写屏障，在指针更新的时候对标记进行更新。按照写屏障更新标记的时机和对象，可以分成Dijkstra算法、Steele算法等。

## ✨ 值得关注的ZGC（可扩展的低延迟垃圾收集器）

> ZGC 由JEP 333集成到 JDK 11 中 ，并在JEP 377中正式中正式发布，官方的描述是：
>
> ZGC is a concurrent, single-generation, region-based, NUMA-aware, compacting collector. 

### ZGC的目标

- GC pause times should not exceed 10ms
- Handle heaps ranging from relatively small (a few hundreds of megabytes) to very large (many terabytes) in size
- No more than 15% application throughput reduction compared to using G1
- Lay a foundation for future GC features and optimizations leveraging colored pointers and load barriers
- Initially supported platform: Linux/x64

### ZGC表现可佳

已使用 SPECjbb® 2015 <sup>[1]</sup> 进行定期性能测量。从吞吐量和延迟的角度来看，性能看起来不错。以下是使用 128G 堆在复合模式下比较 ZGC 和 G1 的典型基准分数（以百分比表示，根据 ZGC 的 max-jOPS 标准化）

```java

（越高越好）

ZGC
       max-jOPS: 100%
  critical-jOPS: 76.1%

G1
       max-jOPS: 91.2%
  critical-jOPS: 54.7%


```

以下是来自同一基准测试的典型 GC 暂停时间。ZGC 设法保持远低于 10 毫秒的目标。请注意，确切的数字可能会有所不同（上下变化，但不显着），具体取决于所使用的确切机器和设置。

```java

ZGC
                avg: 1.091ms (+/-0.215ms)
    95th percentile: 1.380ms
    99th percentile: 1.512ms
  99.9th percentile: 1.663ms
 99.99th percentile: 1.681ms
                max: 1.681ms

G1
                avg: 156.806ms (+/-71.126ms)
    95th percentile: 316.672ms
    99th percentile: 428.095ms
  99.9th percentile: 543.846ms
 99.99th percentile: 543.846ms
                max: 543.846ms

```

还对各种其他 SPEC® 基准和内部工作负载进行了临时性能测量。通常，ZGC 设法维持个位数毫秒的暂停时间。

[1] SPECjbb® 2015 是 Standard Performance Evaluation Corporation (spec.org) 的注册商标。实际结果未表示为合规，因为 SUT 可能不符合 SPEC 对一般可用性的要求。


- 参考 JDK 15 [JEP 377: ZGC: A Scalable Low-Latency Garbage Collector](https://openjdk.java.net/jeps/377)

（待补充）