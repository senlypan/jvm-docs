# 标记-压缩算法

> 作者: 潘深练
>
> 更新: 2022-03-09

## 什么是标记-压缩算法

标记-复制算法在对象存活率较高时就要进行较多的复制操作， 效率将会降低。 更关键的是， 如果不想浪费`50%`的空间， 就需要有额外的空间进行分配担保， 以应对被使用的内存中所有对象都100%存活的极端情况， 所以在**老年代一般不能直接选用这种算法**。

**针对老年代对象的存亡特征**， 1974年Edward Lueders提出了另外一种有针对性的“标记-整理”（`Mark-Compact`） 算法， 其中的标记过程仍然与“标记-清除”算法一样， 但后续步骤不是直接对可回收对象进行清理， 而是让所有存活的对象都向内存空间一端移动， 然后直接清理掉边界以外的内存 。

GC 标记-压缩算法由标记阶段和压缩阶段构成。

GC 标记-压缩算法的标记阶段和标记-清除算法时提到的标记阶段完全一样。而压缩阶段通过数次搜索空闲堆，并重新装填活动对象。它跟 GC 复制算
法不同，不用牺牲半个堆。

GC 标记 - 压缩算法（`Mark Compact GC`）是将 GC 标记 - 清除算法与 GC 复制算法相结合的产物。

![03-mark-compact-001](../_media/image/03-mark-compact/03-mark-compact-001.png)

> 标记-清除算法与标记-压缩算法的本质差异在于前者是一种非移动式的回收算法， 而后者是移动式的。 是否移动回收后的存活对象是一项优缺点并存的风险决策。

是否移动对象都存在弊端， 移动则内存回收时会更复杂， 不移动则内存分配时会更复杂。 从垃圾收集的停顿时间来看， 不移动对象停顿时间会更短， 甚至可以不需要停顿， 但是从整个程序的 **吞吐量** 来看， 移动对象会更划算。

## 优点

### 可有效利用堆

GC 标记 - 压缩算法中会执行压缩，和其他算法相比而言，堆利用效率高。

## 缺点

### 压缩花费计算成本

压缩有着巨大的好处。不过为了享受这些好处，我们也必须做出巨大的牺牲。

执行该算法所花费的时间是和堆大小成正比的。GC 标记 - 压缩算法的吞吐量要劣于其他算法。

在 GC 标记-清除算法中，清除阶段也要搜索整个堆，不过搜索 1 次就够了。但 GC 标记-压缩算法要搜索 3 次，这样就要花费约 3 倍的时间，这是一个相当巨大的缺陷，特别是堆越大，所消耗的成本也就越大。


## 👉 为什么标记复制算法比标记压缩算法快？

Q：标记复制算法和标记整理算法，同样都是移动到堆内存的一端排放。为什么标记复制算法多加了一倍内存就快了？

A: 标记压缩算法必须等 `gcroot` 遍历完，因为堆里面的对象是`网状关联`的，不能一边遍历一边整理，有可能你要整理到的位置还有存活的对象没扫描呢。而标记复制算法开辟的内存完全是一个完全隔离的新区域，所以不用怕覆盖其他对象。所以复制算法新开辟的内存其实是换来了隔离。隔离减少了数据冲突，从而提升了处理性能。（**理解CopyOnWrite思想**）


（本篇完）

?> ❤️ 您也可以参与梳理，快来提交 [issue](https://github.com/senlypan/jvm-docs/issues) 或投稿参与吧~